# Создание контейнера Nginx

И вот мы сделали снапшот, сохранили конфигурацию в облако или на флешку и готовы приступать к развёртыванию контейнеров непосредственно проекта.

Сначала давайте познакомимся с технологиями, которые мы будем использовать в наших контейнерах.

В нашем задании дана следующая схема:

![настройка nginx](media/nginx_deploy/step_1.png)

Давайте посмотрим, какой софт нам необходим, чтобы реализовать то, что нарисовано на схеме:

Технология | Назначение | Создатель | Порты
------ | ------ | ------ | ------ | 
Nginx | Проксирующий веб-сервер | Игорь Сысоев (Россия) | 443 |
PHP	| Скриптовой язык для веб | Расмус Лердорф (Дания) | - |
Php-Fpm	| Набор библиотек для FastCGI API | Андрей Нигматулин (Россия) | 9000 |
Wordpress | Системуа управления содержимым | Мэтью Мулленвег (США) | - |
MariaDB | Реляционная база данных | Микаэль Видениус (Финляндия) | 3306 |
---
Эта таблица сразу же приобщает нас к перкрасному, ибо здесь прекрасно всё.

Лучший проксирующий веб-сервер, созданный нашим соотечественником Игорем Сысоевым, занимающий 30% рынка серверов. Именно на этой прекрасно задокументированной софтине держится 30% интернета и львиная доля больших и высоконагруженных сайтов, ибо именно под высокие нагрузки этот сервер и писался c 2002 года.

Именно его мы будем настраивать в этом гайде, а пока познакомимся с остальными нужными нам технологиями.

Язык PHP создан датчанином Лердорфом для личных целей в 1995 году, однако он быстро завоевал популярность в веб-разработке и до сих пор является одним из лидирующих языков для веба.

Библиотека php-fpm от нашего соотечественника Андрея Нигматулина стала стандартным API между php и веб-серверами, в том числе Nginx-ом. Именно она подружит наш nginx с php. Устанавливается в контейнер с php.

Wordpress - замечательная и лёгкая в настройке CMS - система, изучив которую можно начинать принимать заказы на сайты на фрилансе :). Создана в 2003 году.

MariaDB - легковесный аналог базы данных MySQL. И то и другое - творение финна Видениуса, назвавшего MySQL в честь своей старшей дочери Мю, а MariaDB - в честь младшей, Марии.

Все эти технологии относительно просты, лакончины и функциональны, что делает их прекрасным выбором и для начинающих веб-программистов, и для профессионалов.

И всё это работает под управлением ОС Linux - прекрасного творения финна Линуса Торвальдса, на котором зиждется весь современный интернет, и крутится внутри контейнеров Docker, системы контейнеризации, созданной американцем Соломоном Хайксом. Ядро Линукс появилось в 1992-93, а Docker в 2013-м.

![настройка nginx](media/nginx_deploy/step_0.png)

Вот так два американца, двое русских и два финна создали все необходимые нам для задания технологии. И как-то случайно между ними затесался живущий в Канаде датчанин, создатель одной из базовых технологий - самого языка, который используется нами для wordpress.

Итак, приступим к настройке сервера с Nginx.

## Шаг 1. Введение в Docker

Докер образ - это набор окружения, необходимого для запуска определённого софта. От эмуляторов по типу virtualbox он отличается тем, что в контенере не содержится полноценной операционной системы, контейнер использует ядро Linux и внутрь него помещаются не все, а только необходимые для запуска софта программы и библиотеки.

Таким образом контейнер весит значительно меньше, чем эмулируемая система. Убедимся в этом наглядно. Посмотрим, сколько весит наша ОС в установленном виде:

![настройка nginx](media/nginx_deploy/step_2.png)

И сравним это с тем же образом одиннадцатого debian на [Docker Hub](https://hub.docker.com/ "docker hub") - официальном хранилище образов Docker:

![настройка nginx](media/nginx_deploy/step_3.png)

Образ весит всего 50 МБ в сжатом виде (сжатый диск с Debian у нас весил 950 МБ!). После распаковки этот образ будет весить около 150 МБ. Вот такая значительная разница. И это далеко не предел.

Всё потому, что для запуска отдельного софта не нужна вся полноценная операционная система, достаточно рабочего ядра и некоторого окружения из всех зависимостей - модулей, библиотек, пакетов и скриптов. По такому принципу работает wine, само название которого гласит что Wine - Is Not Emulator. Он помогает запускать виндовые приложения в среде линукс, устанавливая только нужные зависимости и ничего лишнего.

Мы будем использовать легковесную систему alpine, которая используется для контейнеров и микроконтроллеров, но может так же быть установлена в эмулятор или на реальное железо. Система отличается крайне малым весом: около 50 мегабайт вместе с ядром, 30 мегабайт в распакованном и 2,5 (!) мегабайт в сжатом виде (да, репозитории linux используют продвинутые методы сжатия для экономии трафика, но полноценная ОС весом 2,5 МБ всё равно удивляет):

![настройка nginx](media/nginx_deploy/step_7.png)

Разница сжатого формата с тем же debian - аж в 20 раз! Это было достигнуто благодаря оптимизации всего и вся, но это же накладывает ограничения. Так в системе используется легковесный apk вместо привычного apt, нет полноценного bash, вместо него используется sh, естественно, [свой набор репозиториев](https://pkgs.alpinelinux.org/packages "список пакетов alpine") и много других особенностей.

Впрочем, как и в любой open-sources linux сюда многое можно добавить. И именно этот дистр стал основной для многих docker-проектов из-за малого веса, высокой скорости работы и высокой отказоустойчивости. Чем больше и сложнее система, тем больше и точек отказа, стало быть, легковесные дистрибутивы имеют в этом случае большие преимущества.

Итак, когда мы закончили ревью и разобрались в отличии эмуляторов и контейнеров, переходим к изучению того, как работает Docker.

## Шаг 2. Создание Dockerfile

В Докере за конфигурацию отвечает специальный файл, который называется Dockerfile. В нём прописывается набор софта, который мы хотим развернуть внутри данного контейнера.

Переходим в папку нашего nginx:

```cd ~/project/srcs/requirements/nginx/```

Создаём в ней Dockerfile:

```nano Dockerfile```

И прописываем в нём инструкцию FROM, которая указывает из какого образа мы будем разворачивать наш контейнер. По subject нам запрещено указывать лейблы вроде alpine:latest, автоматически присваиваемые последним версиям alpine в репозиториях dockerhub. Потому заходим на [официальный сайт](https://www.alpinelinux.org/ "версии alpine") системы и смотрим, какой выпуск самый последний. На момент написания гайда это был alpine 3.16.2, ну а для инструкции FROM будет достаточно указать младшую версию:

```FROM alpine:3.16```

Подробнее о инструкциях можно посмотреть в [этом видео](https://www.youtube.com/watch?v=wskg5903K8I "docker от Антона Павленко"), здесь же разберём лишь некоторые из них.

Далее мы прописываем, какой софт и как мы хотим установить внутрь контейнера. В этом нам поможет инструкция RUN.

Инструкция ``RUN`` создаёт новый слой образа с результатом вызванной команды, подобно тому, как система снапшотов сохраняет изменения в виртуальной машине. Собственно, сам образ и состаит из таких вот слоёв-изменений.

Из ``RUN`` невозможно запустить приложение напрямую. В ряде случаев это можно делать через скрипт, но в целом для запуска используются инструкции ``CMD`` и ``ENTRYPOINT``. ``RUN`` создаёт статичный слой, изменения внутри которого записываются в образ, но ничего не вызывают, ``CMD`` и ``ENTRYPOINT`` запускают что-либо, но НЕ ЗАПИСЫВАЮТ изменений в образ. Потому не стоит выполнять ими скрипты, результат которых нужно "положить" в конечный образ или раздел. Для этого есть ``RUN``.

Можно сказать, что сделанные через ``RUN`` изменения статичны. Например, установка пакетов в системе обычно делается так:

```RUN	apk update && apk upgrade && apk add --no-cache nginx```

Здесь мы говорим файловому менеджеру apk чтобы он обновил список своих репозиториев в поисках последних версий софта (apk update), обновил устаревшие пакеты в нашем окружении (apk upgrade) и установил nginx не сохраняя исходники в кэше (apk add --no-cache nginx). Работает почти так же, как ```apt``` в debian.

Затем нам нужно открыть порт, по которому контейнер будет обмениваться трафиком:

```EXPOSE 443```

В конце концов мы должны запустить установленную конфигурацию. Для этого используем инструкцию ```CMD```:

```CMD ["nginx", "-g", "daemon off;"]```

Таким образом мы запускаем nginx напрямую, а не в режиме демона. Режим демона же, это такой режим запуска, в котором приложение стартует в фоне или выражаясь языком windows, как служба. Для удобства отладки мы отключаем этот режим и получаем все логи nginx напрямую в tty контейнера.

```
FROM alpine:3.16
RUN	apk update && apk upgrade && apk add --no-cache nginx
EXPOSE 443
CMD ["nginx", "-g", "daemon off;"]
```
Вот, собственно, и весь Dockerfile. Просто, не правда ли?

![установка nginx](media/stickers/easy.png)

Сохраняем, закрываем.

## Шаг 3. Создание файла конфигурации

Естественно, наш nginx не заработает без конфигурационного файла. Напишем же его!

Посмотрев при помощи ```ls``` нашу папку с nginx-ом мы обнаружим в ней директории conf и tools. Стало быть, наша конфигурация должна лежать в папке conf, если мы нормальные белые люди (никакого расизма, просто расхожая фраза).

Создадим наш конфиг прямо отсюда:

```nano conf/nginx.conf```

Так как мы уже тренировались с тестовым контейнером, возьмём похожую конфигурацию, изменив её под php, чтобы она позволяла читать не html, а php файлы wordpress-а. Порт 80 нам больше не понадобится, так как по гайду мы можем использовать только порт 443. Но на первом этапе мы закомментируем секции, отвечающие за php, и пропишем на время поддержку html (для проверки):
```
server {
    listen      443 ssl;
    server_name  <your_nickname>.42.fr www.<your_nickname>.42.fr;
    root    /var/www/;
    index index.php index.html;
    ssl_certificate     /etc/nginx/ssl/<your_nickname>.42.fr.crt;
    ssl_certificate_key /etc/nginx/ssl/<your_nickname>.42.fr.key;
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_session_timeout 10m;
    keepalive_timeout 70;
    location / {
        try_files $uri /index.php?$args /index.html;
        add_header Last-Modified $date_gmt;
        add_header Cache-Control 'no-store, no-cache';
        if_modified_since off;
        expires off;
        etag off;
    }
#    location ~ \.php$ {
#        fastcgi_split_path_info ^(.+\.php)(/.+)$;
#        fastcgi_pass wordpress:9000;
#        fastcgi_index index.php;
#        include fastcgi_params;
#        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
#        fastcgi_param PATH_INFO $fastcgi_path_info;
#    }
}
```

Порт 9000 - это как раз порт нашего php-fpm, по которому осуществляется соединение между php и nginx. А wordpress в данном случае - имя нашего контейнера с wordpress-ом. Но пока попытаемся хотя бы просто запустить что-то на nginx-е.

Просто копипастим это в наш проект и сохраняем файл.

А папку tools я использую для ключей, скопировав их туда:

```cp ~/project/srcs/requirements/tools/* ~/project/srcs/requirements/nginx/tools/```

![установка nginx](media/stickers/understand.png)

## Шаг 4. Создание конфигурации docker-compose

Docker-compose - это система запуска контейнеров docker, можно сказать, это некая надстройка над docker. Если в docker-файлах мы прописывали, какой софт установить внутри одного контейнерного окружения, то с docker-compose мы можем управлять запуском сразу множества подобных контейнеров, запуская их одной командой.

Для этого переходим на два уровня выше (``../../``) и правим наш уже созданный docker-compose файл:

```cd ../../ && nano docker-compose.yml```

Сначала прописываем версию. Последняя версия - третья.

```
version: '3'

services:
  nginx:
```

Первым в списке наших сервисов будет nginx. Ставим два пробела и прописываем это слово.

Далее мы говорим докеру, где лежит наш Dockerfile:

```
version: '3'

services:
  nginx:
    build:
      context: .
      dockerfile: requirements/nginx/Dockerfile
```

Задаём имя нашему контейнеру, а так же пробрасываем нужный порт (в этом задании мы можем использовать только ssl).

Так же пропишем зависимость, пока закомментировав её. Нам нужно, чтобы nginx стартовал после wordpress-а, подхватывая его сборку. Но nginx собирается быстрее, и  во избежании коллизий нам необходимо чтобы он подождал сборки контейнера с wordpress и запустился только после него. Пока для тестов закомментируем это.

```
version: '3'

services:
  nginx:
    build:
      context: .
      dockerfile: requirements/nginx/Dockerfile
    container_name: nginx
#    depends_on:
#      - wordpress
    ports:
      - "443:443"
```

Добавляем разделы, чтобы контейнер увидел наш конфиг и наши ключи, а так же обязательно монтируем наш /var/www - ту самую папку из старой конфигурации, которая понадобится нам для пробного запуска nginx. Позже мы удалим её и будем брать файлы из каталога wordpress-а.

```
version: '3'

services:
  nginx:
    build:
      context: .
      dockerfile: requirements/nginx/Dockerfile
    container_name: nginx
#    depends_on:
#      - wordpress
    ports:
      - "443:443"
    volumes:
      - ./requirements/nginx/conf/:/etc/nginx/http.d/
      - ./requirements/nginx/tools:/etc/nginx/ssl/
      - /home/${USER}/simple_docker_nginx_html/public/html:/var/www/
```

Дальше мы прописываем тип перезапуска. В боевых проектах лично я использую тип restart: unless-stopped (перезапускать всегда, за исключением команды остановки), но сабжем он запрещён, потому выставляем разрешённый:

```
    restart: always
```

...что значит перезапускать в любом случае.

И таким образом мы имеем следующую конфигурацию:

```
version: '3'

services:
  nginx:
    build:
      context: .
      dockerfile: requirements/nginx/Dockerfile
    container_name: nginx
#    depends_on:
#      - wordpress
    ports:
      - "443:443"
    volumes:
      - ./requirements/nginx/conf/:/etc/nginx/http.d/
      - ./requirements/nginx/tools:/etc/nginx/ssl/
      - /home/${USER}/simple_docker_nginx_html/public/html:/var/www/
    restart: always
```

Не забываем выключить тестовую конфигурацию:

```cd ~/simple_docker_nginx_html/```

```docker-compose down```

И запускаем нашу новую конфигурацию:

```cd ~/project/srcs/```

```docker-compose up -d```

Так как мы используем 443 порт, а он поддерживает только https-пртоткол, мы обратимся к адресу по https:

```https://127.0.0.1``` в браузере

```https://<your_nickname>.42.fr``` в GUI

И теперь, если мы обратимся к локальному хосту из браузера, мы получим рабочую конфигурацию:

![рабочий nginx](media/install_certificate/step_10.png)

Путём лёгкой замены нескольких значений docker-compose и раскомментирования файла конфигурации мы получим рабочий nginx, поддерживающий tls и работающий с wordpress. Но это будет дальше.

А пока делаем снапшоты, сохраняемся в облако, наливаем приятную для организма жидкость и наслаждаемся жизнью. На то мы и devops-инженеры :)

![настройка vsftpd](media/stickers/drink.png)